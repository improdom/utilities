using System.Data;
using System.Linq;
using System.Threading;

public async Task<DataTable> ExecuteSqlAsync(string sql, TokenCredentials credentials, CancellationToken cancellationToken = default)
{
    try
    {
        var tokenClient = new TokenClient(credentials);
        var token = await tokenClient.GetToken(httpClient);
        using var client = DatabricksClient.CreateClient(DatabricksUrl, token.AccessToken);

        var sqlStatement = new SQLStatement
        {
            Statement = sql,
            WarehouseId = "b25bd389b4ufc4e" // Make this configurable ideally
        };

        var result = await client.SQL.StatementExecution.Execute(sqlStatement, cancellationToken);
        var statementId = result.StatementId;

        // Wait for query completion
        while (result.Status.State == StatementExecutionState.PENDING || result.Status.State == StatementExecutionState.RUNNING)
        {
            cancellationToken.ThrowIfCancellationRequested();
            await Task.Delay(500, cancellationToken);
            result = await client.SQL.StatementExecution.GetStatus(statementId, cancellationToken);
        }

        if (result.Status.State != StatementExecutionState.SUCCEEDED)
            throw new Exception($"SQL execution failed: {result.Status.State}");

        var dataTable = new DataTable();
        var chunkIndex = 0;
        bool columnsInitialized = false;

        while (true)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var chunk = await client.SQL.StatementExecution.GetResultChunk(statementId, chunkIndex, cancellationToken);

            if (chunk.DataArray == null || !chunk.DataArray.Any())
                break;

            // Initialize DataTable columns from metadata once
            if (!columnsInitialized && chunk.Manifest?.Schema?.Columns != null)
            {
                foreach (var column in chunk.Manifest.Schema.Columns)
                {
                    dataTable.Columns.Add(column.Name, MapDatabricksTypeToClrType(column.Type));
                }
                columnsInitialized = true;
            }

            // Fill the DataTable
            foreach (var row in chunk.DataArray)
            {
                var dataRow = dataTable.NewRow();
                for (int i = 0; i < row.Count; i++)
                {
                    dataRow[i] = row[i] ?? DBNull.Value;
                }
                dataTable.Rows.Add(dataRow);
            }

            chunkIndex++;
        }

        return dataTable;
    }
    catch (OperationCanceledException)
    {
        Console.WriteLine("SQL Execution cancelled.");
        throw;
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Exception executing SQL: {ex}");
        throw;
    }
}
private Type MapDatabricksTypeToClrType(string databricksType)
{
    return databricksType.ToLowerInvariant() switch
    {
        "string" => typeof(string),
        "boolean" => typeof(bool),
        "byte" => typeof(byte),
        "short" => typeof(short),
        "integer" => typeof(int),
        "long" => typeof(long),
        "float" => typeof(float),
        "double" => typeof(double),
        "decimal" => typeof(decimal),
        "date" => typeof(DateTime),
        "timestamp" => typeof(DateTime),
        _ => typeof(string) // Default fallback
    };
}
